import { restartSim } from './physics.js';
import { getId, uid } from './utils.js';

export const state = {
    nodes: [],
    links: [],
    nextId: 1,
    selection: null,
    hoverId: null,
    focusMode: false,
    focusSet: new Set(),
    hvtMode: false,
    hvtTopN: 10,
    hvtTopIds: new Set(),
    pathfinding: { startId: null, active: false, pathNodes: new Set(), pathLinks: new Set() },
    pathMode: false,
    pathPath: new Set(),
    activeFilter: 'ALL',
    globeMode: true,
    physicsSettings: {
        repulsion: 1200, gravity: 0.005, linkLength: 220, friction: 0.3, 
        collision: 50, enemyForce: 300, structureRepulsion: 0.1, curveStrength: 1.0
    },
    history: [], tempLink: null, labelMode: 1, showLinkTypes: false, 
    performance: false, view: { x: 0, y: 0, scale: 0.8 }, forceSimulation: false,
    projectName: null, // AJOUT DU NOM DU PROJET
    aiSettings: {
        mode: 'decouverte',
        scope: 'selection',
        limit: 20,
        minScore: 0.35,
        noveltyRatio: 0.25,
        sources: { graph: true, text: true, tags: true, profile: true, bridge: true, lex: true, geo: true },
        showReasons: true,
        showPredicted: true,
        intelUnlocked: false
    },
    aiFeedback: {},
    aiPredictedLinks: []
};

const STORAGE_KEY = 'pointPageState_v13'; 
let saveTimer = null;

export function saveState() {
    try {
        const payload = {
            meta: { projectName: state.projectName }, // SAUVEGARDE DU NOM
            nodes: state.nodes.map(n => ({
                id: n.id, name: n.name, type: n.type, color: n.color, 
                num: n.num, notes: n.notes, x: n.x, y: n.y, fixed: n.fixed,
                linkedMapPointId: n.linkedMapPointId 
            })),
            links: state.links.map(l => ({
                id: l.id,
                source: (typeof l.source === 'object') ? l.source.id : l.source,
                target: (typeof l.target === 'object') ? l.target.id : l.target,
                kind: l.kind
            })),
            view: state.view, labelMode: state.labelMode, showLinkTypes: state.showLinkTypes,
            activeFilter: state.activeFilter, globeMode: state.globeMode, hvtTopN: state.hvtTopN,
            physicsSettings: state.physicsSettings, nextId: state.nextId,
            aiSettings: state.aiSettings, aiFeedback: state.aiFeedback,
            aiPredictedLinks: state.aiPredictedLinks
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    } catch (e) { console.error("Save error", e); }
}

export function scheduleSave(delay = 400) {
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
        saveTimer = null;
        saveState();
    }, delay);
}

export function loadState() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const data = JSON.parse(raw);
        if (data.nodes) state.nodes = data.nodes;
        if (data.links) state.links = data.links;
        if (data.view) state.view = data.view;
        if (data.nextId) state.nextId = data.nextId;
        if (typeof data.labelMode === 'number') state.labelMode = data.labelMode;
        if (data.activeFilter) state.activeFilter = data.activeFilter;
        if (typeof data.globeMode === 'boolean') state.globeMode = data.globeMode;
        if (typeof data.hvtTopN === 'number') state.hvtTopN = data.hvtTopN;
        if (data.physicsSettings) state.physicsSettings = { ...state.physicsSettings, ...data.physicsSettings };
        if (data.aiSettings) {
            state.aiSettings = { ...state.aiSettings, ...data.aiSettings };
            if (data.aiSettings.sources) {
                state.aiSettings.sources = { ...state.aiSettings.sources, ...data.aiSettings.sources };
            }
        }
        state.aiSettings.intelUnlocked = false;
        if (data.aiFeedback) state.aiFeedback = data.aiFeedback;
        if (data.aiPredictedLinks) state.aiPredictedLinks = data.aiPredictedLinks;
        if (data.meta && data.meta.projectName) state.projectName = data.meta.projectName; // CHARGEMENT DU NOM
        ensureLinkIds();
        state.pathfinding = { startId: null, active: false, pathNodes: new Set(), pathLinks: new Set() };
        state.hvtMode = false;
        state.hvtTopIds = new Set();
        return true;
    } catch (e) { return false; }
}

export function pushHistory() {
    if (state.history.length > 50) state.history.shift();
    const snapshot = {
        nodes: state.nodes.map(n => ({...n})),
        links: state.links.map(l => ({
            id: l.id,
            source: (typeof l.source === 'object') ? l.source.id : l.source,
            target: (typeof l.target === 'object') ? l.target.id : l.target,
            kind: l.kind
        })),
        nextId: state.nextId
    };
    state.history.push(JSON.stringify(snapshot));
}

export function undo() {
    if (state.history.length === 0) return;
    const prevJSON = state.history.pop();
    const prev = JSON.parse(prevJSON);
    state.nodes = prev.nodes;
    state.links = prev.links;
    ensureLinkIds();
    state.nextId = prev.nextId;
    restartSim();
}

export function ensureLinkIds() {
    state.links.forEach(l => {
        if (!l.id) l.id = uid();
    });
}

export function nodeById(id) {
    const target = String(id);
    return state.nodes.find(n => String(n.id) === target);
}

export function linkHasNode(link, nodeId) {
    const target = String(nodeId);
    return getId(link.source) === target || getId(link.target) === target;
}
export function isPerson(n) { return n.type === 'person'; }
export function isGroup(n) { return n.type === 'group'; }
export function isCompany(n) { return n.type === 'company'; }
